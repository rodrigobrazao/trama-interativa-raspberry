<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TRAMA - Instalacao Interativa</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100vw; height: 100vh;
            overflow: hidden;
            background: #000;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .canvas-container {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
        }

        #webcam {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.4;
        }

        #mainCanvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }

        /* Canvas oculto para motion detection */
        #motionCanvas { display: none; }
        #prevCanvas { display: none; }

        #status {
            position: absolute; bottom: 20px; left: 20px;
            color: white; background: rgba(0,0,0,0.8);
            padding: 10px 15px; border-radius: 5px;
            font-size: 14px; z-index: 100;
            transition: opacity 2s;
        }

        /* Menu hamburger */
        #menuToggle {
            position: absolute; top: 10px; right: 10px;
            width: 36px; height: 36px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px; cursor: pointer; z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 4px; padding: 0;
            transition: opacity 0.5s;
            opacity: 0;
        }
        #menuToggle:hover { background: rgba(0,0,0,0.85); }
        #menuToggle span {
            display: block; width: 16px; height: 2px;
            background: white; border-radius: 1px;
            transition: transform 0.3s, opacity 0.3s;
        }
        #menuToggle.open span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
        #menuToggle.open span:nth-child(2) { opacity: 0; }
        #menuToggle.open span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

        #controls {
            position: absolute; top: 52px; right: 10px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 12px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            color: white; z-index: 150;
            min-width: 180px;
            transform: translateX(calc(100% + 20px));
            opacity: 0; pointer-events: none;
            transition: transform 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.3s ease;
        }
        #controls.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }

        .control-group { margin-bottom: 8px; }
        label { display: block; margin-bottom: 2px; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.7; }
        input[type="range"] { width: 100%; margin-top: 2px; height: 18px; }
        .value-display { text-align: right; font-size: 11px; margin-top: 1px; font-weight: bold; }
    </style>
</head>
<body>
    <button id="menuToggle" aria-label="Menu">
        <span></span><span></span><span></span>
    </button>

    <div id="controls">
        <div class="control-group">
            <label>Elasticidade</label>
            <input type="range" id="elasticity" min="0.02" max="0.15" step="0.01" value="0.08">
            <div class="value-display" id="elasticity-value">0.08</div>
        </div>
        <div class="control-group">
            <label>Densidade de Malha</label>
            <input type="range" id="gridDensity" min="10" max="30" step="2" value="18">
            <div class="value-display" id="density-value">18</div>
        </div>
        <div class="control-group">
            <label>Raio de Captura</label>
            <input type="range" id="captureRadius" min="20" max="120" step="5" value="80">
            <div class="value-display" id="capture-value">80</div>
        </div>
        <div class="control-group">
            <label>Sensibilidade</label>
            <input type="range" id="sensitivity" min="10" max="80" step="5" value="30">
            <div class="value-display" id="sensitivity-value">30</div>
        </div>
        <div class="control-group">
            <label>Opacidade Video</label>
            <input type="range" id="videoOpacity" min="0" max="100" step="5" value="40">
            <div class="value-display" id="opacity-value">40%</div>
        </div>
        <div class="control-group">
            <label>Força</label>
            <input type="range" id="forceMultiplier" min="50" max="300" step="10" value="150">
            <div class="value-display" id="force-value">150</div>
        </div>
    </div>

    <div id="status">A iniciar...</div>

    <div class="canvas-container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- Canvas ocultos para motion detection -->
    <canvas id="motionCanvas"></canvas>
    <canvas id="prevCanvas"></canvas>

    <script>
        // ════════════════════════════════════════
        // CONFIG — Versão LITE (sem MediaPipe)
        // Usa detecção de movimento por diferença de frames
        // ════════════════════════════════════════
        const CAM_WIDTH = 160;   // Resolução interna para motion detection
        const CAM_HEIGHT = 120;
        const MOTION_GRID = 8;   // Divide a imagem em blocos de 8x8 pixels

        let canvas, ctx, webcam;
        let motionCanvas, motionCtx;
        let prevCanvas, prevCtx;
        let isRunning = false;
        let hasPrevFrame = false;

        // Pontos de movimento detectados
        let motionPoints = [];

        const CONFIG = {
            elasticity: 0.08,
            gridDensity: 18,
            captureRadius: 80,
            damping: 0.85,
            videoOpacity: 0.4,
            sensitivity: 30,       // Limiar de diferença de pixel (0-255)
            forceMultiplier: 150    // Multiplicador de força do movimento
        };

        let points = [];
        let cols, rows;

        // SVG TRAMA polylines
        const svgPolylines = [
            {points: "6980.13 6861.04 6566.36 7471.99 6239.5 7382.51 6239.5 6813.14 6612.26 6781.51 6747.18 6659.5 6923.82 6861.04", style: 1},
            {points: "6662.23 6736.32 6836.2 6955.03 6816.72 7739.5 7198.48 7739.5 6709.62 7207.18 6749.12 6984.73 6633.21 6762.57", style: 1},
            {points: "7198.48 7739.5 7208.96 6861.04 6923.82 6861.04 6836.2 6955.03 6796.27 7039.51", style: 1},
            {points: "6239.5 7382.51 6239.5 7739.5 6816.72 7739.5 6566.36 7471.99", style: 1},
            {points: "6239.5 6813.14 6240.71 6659.5 6747.18 6659.5 7218.69 6659.5 7208.96 6861.04", style: 1},
            {points: "7939.11 6861.04 7525.34 7471.99 7204.18 7413.44 7208.96 6861.04 7421.8 6960.37 7706.16 6659.5 7882.81 6861.04", style: 1},
            {points: "7471.77 6907.5 7795.18 6955.03 7775.71 7739.5 8157.47 7739.5 7668.61 7207.18 7757.63 6974.91 7442.75 6941.43", style: 1},
            {points: "8157.47 7739.5 8157.47 6861.04 7882.81 6861.04 7795.18 6955.03 7757.63 6974.91", style: 1},
            {points: "7198.48 7739.5 7775.71 7739.5 7525.34 7471.99", style: 1},
            {points: "7218.69 6659.5 7706.16 6659.5 8157.47 6659.5 8157.47 6861.04", style: 1},
            {points: "6749.12 6922.63 7289.77 7378.99 7237.96 7739.91 6749.12 7739.55 6837.03 7493.19 6570.78 7179.56 6749.12 6984.73", style: 2},
            {points: "6790.24 7438.08 6832.3 7081.37 7526.5 7102.85 7526.5 6659.5 7055.44 7220.98 7085.09 7431.06 6820.27 7470.09", style: 2},
            {points: "7526.5 6659.5 6747.18 6659.5 6749.12 6984.73 6832.3 7081.37 7085.09 7431.06", style: 2},
            {points: "7526.5 7739.5 7526.5 7102.85 7289.77 7378.99", style: 2},
            {points: "6570.78 7739.91 6570.78 7179.56 6570.78 6659.5 6752.74 6659.5", style: 2}
        ];

        const SVG_AREA = { x: 6239.5, y: 6659.5, width: 1917.97, height: 1080 };

        // ════════════════════════════════════════
        // POINT CLASS (sem som)
        // ════════════════════════════════════════
        class Point {
            constructor(x, y, col, row) {
                this.x = x; this.y = y; this.z = 0;
                this.originalX = x; this.originalY = y; this.originalZ = 0;
                this.vx = 0; this.vy = 0; this.vz = 0;
                this.col = col; this.row = row;
            }

            applyForce(fx, fy, strength) {
                this.vx += fx * strength;
                this.vy += fy * strength;
                this.vz += strength * 50;
            }

            update() {
                let fx = (this.originalX - this.x) * CONFIG.elasticity;
                let fy = (this.originalY - this.y) * CONFIG.elasticity;
                let fz = (this.originalZ - this.z) * CONFIG.elasticity * 2;
                this.vx += fx; this.vy += fy; this.vz += fz;
                this.vx *= CONFIG.damping; this.vy *= CONFIG.damping; this.vz *= CONFIG.damping * 0.9;
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
            }
        }

        // ════════════════════════════════════════
        // GRID (responsive)
        // ════════════════════════════════════════
        function createGrid() {
            points = [];
            let scale = Math.min(canvas.width / SVG_AREA.width, canvas.height / SVG_AREA.height) * 0.8;
            let svgW = SVG_AREA.width * scale;
            let svgH = SVG_AREA.height * scale;
            let offsetX = (canvas.width - svgW) / 2;
            let offsetY = (canvas.height - svgH) / 2;

            cols = CONFIG.gridDensity;
            rows = Math.floor(cols * (svgH / svgW));

            let spacingX = svgW / cols;
            let spacingY = svgH / rows;

            for (let i = 0; i <= cols; i++) {
                points[i] = [];
                for (let j = 0; j <= rows; j++) {
                    points[i][j] = new Point(
                        offsetX + i * spacingX,
                        offsetY + j * spacingY,
                        i, j
                    );
                }
            }
        }

        // ════════════════════════════════════════
        // MOTION DETECTION (diferença de frames)
        // ════════════════════════════════════════
        function detectMotion() {
            motionPoints = [];

            // Desenhar frame actual no motion canvas
            motionCtx.drawImage(webcam, 0, 0, CAM_WIDTH, CAM_HEIGHT);
            const currentFrame = motionCtx.getImageData(0, 0, CAM_WIDTH, CAM_HEIGHT);

            if (!hasPrevFrame) {
                // Guardar primeiro frame e sair
                prevCtx.putImageData(currentFrame, 0, 0);
                hasPrevFrame = true;
                return;
            }

            const prevFrame = prevCtx.getImageData(0, 0, CAM_WIDTH, CAM_HEIGHT);
            const current = currentFrame.data;
            const prev = prevFrame.data;

            // Analisar por blocos
            const blockW = MOTION_GRID;
            const blockH = MOTION_GRID;
            const blocksX = Math.floor(CAM_WIDTH / blockW);
            const blocksY = Math.floor(CAM_HEIGHT / blockH);

            for (let bx = 0; bx < blocksX; bx++) {
                for (let by = 0; by < blocksY; by++) {
                    let totalDiff = 0;
                    let diffX = 0, diffY = 0;
                    let count = 0;

                    // Somar diferenças no bloco
                    for (let px = bx * blockW; px < (bx + 1) * blockW; px++) {
                        for (let py = by * blockH; py < (by + 1) * blockH; py++) {
                            let idx = (py * CAM_WIDTH + px) * 4;
                            let dr = Math.abs(current[idx] - prev[idx]);
                            let dg = Math.abs(current[idx+1] - prev[idx+1]);
                            let db = Math.abs(current[idx+2] - prev[idx+2]);
                            let diff = (dr + dg + db) / 3;

                            if (diff > CONFIG.sensitivity) {
                                totalDiff += diff;
                                count++;
                            }
                        }
                    }

                    if (count > (blockW * blockH) * 0.2) {
                        // Movimento detectado neste bloco
                        // Mapear coordenadas do bloco para o canvas (espelhado)
                        let nx = 1 - ((bx + 0.5) / blocksX); // Espelhar X (webcam mirror)
                        let ny = (by + 0.5) / blocksY;
                        let strength = Math.min(1, totalDiff / (count * 80));

                        motionPoints.push({
                            x: nx * canvas.width,
                            y: ny * canvas.height,
                            strength: strength
                        });
                    }
                }
            }

            // Guardar frame actual como anterior
            prevCtx.putImageData(currentFrame, 0, 0);
        }

        // ════════════════════════════════════════
        // RENDER
        // ════════════════════════════════════════
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Aplicar forças dos pontos de movimento aos pontos da grelha
            for (let mp of motionPoints) {
                for (let i = 0; i <= cols; i++) {
                    for (let j = 0; j <= rows; j++) {
                        let p = points[i][j];
                        let dx = p.originalX - mp.x;
                        let dy = p.originalY - mp.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < CONFIG.captureRadius) {
                            let falloff = 1 - (dist / CONFIG.captureRadius);
                            let force = falloff * mp.strength * (CONFIG.forceMultiplier / 1000);
                            // Empurrar para fora do centro de movimento
                            let angle = Math.atan2(dy, dx);
                            p.applyForce(
                                Math.cos(angle) * force,
                                Math.sin(angle) * force,
                                falloff * mp.strength
                            );
                        }
                    }
                }
            }

            // Update physics
            for (let i = 0; i <= cols; i++)
                for (let j = 0; j <= rows; j++)
                    points[i][j].update();

            // Draw
            drawMotionGlow();
            drawDistortedPolylines();
        }

        function drawMotionGlow() {
            // Visualizar zonas de movimento com glow subtil
            for (let mp of motionPoints) {
                let alpha = mp.strength * 0.15;
                let radius = CONFIG.captureRadius * mp.strength;
                let gradient = ctx.createRadialGradient(mp.x, mp.y, 0, mp.x, mp.y, radius);
                gradient.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDistortedPolylines() {
            let scale = Math.min(canvas.width / SVG_AREA.width, canvas.height / SVG_AREA.height) * 0.8;
            let svgW = SVG_AREA.width * scale;
            let svgH = SVG_AREA.height * scale;
            let offsetX = (canvas.width - svgW) / 2;
            let offsetY = (canvas.height - svgH) / 2;

            for (let polyline of svgPolylines) {
                let coords = polyline.points.trim().split(/\s+/);
                let pts = [];
                for (let i = 0; i < coords.length; i += 2) {
                    let svgX = parseFloat(coords[i]);
                    let svgY = parseFloat(coords[i + 1]);
                    let x = ((svgX - SVG_AREA.x) / SVG_AREA.width) * svgW + offsetX;
                    let y = ((svgY - SVG_AREA.y) / SVG_AREA.height) * svgH + offsetY;
                    pts.push(getDistortedPoint(x, y));
                }

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    let avgZ = (pts[i-1].z + pts[i].z) / 2;
                    let nZ = Math.max(0, Math.min(1, (avgZ + 150) / 300));
                    let baseWidth = polyline.style === 1 ? 3 : 2;

                    ctx.lineWidth = baseWidth * (0.5 + nZ * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + nZ * 0.6})`;

                    if (nZ > 0.6) {
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                        ctx.shadowBlur = (nZ - 0.6) * 20;
                    } else { ctx.shadowBlur = 0; }

                    ctx.lineTo(pts[i].x, pts[i].y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(pts[i].x, pts[i].y);
                }
                ctx.shadowBlur = 0;
            }

            drawDistortedTRAMA(offsetX, offsetY, svgW, svgH);
        }

        function drawDistortedTRAMA(offsetX, offsetY, svgW, svgH) {
            let word = 'TRAMA';
            let letterSpacing = svgW / 8;
            let startX = offsetX + svgW / 2 - (word.length * letterSpacing) / 2;
            let centerY = offsetY + svgH / 2;

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < word.length; i++) {
                let x = startX + i * letterSpacing + letterSpacing / 2;
                let distorted = getDistortedPoint(x, centerY);

                let nZ = Math.max(0, Math.min(1, (distorted.z + 150) / 300));
                let baseFontSize = Math.min(canvas.width, canvas.height) * 0.09;
                let size = baseFontSize * (0.6 + nZ * 0.8);

                ctx.font = `bold ${size}px Helvetica, Arial, sans-serif`;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + nZ * 0.5})`;

                if (nZ > 0.6) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = (nZ - 0.6) * 40;
                } else { ctx.shadowBlur = 0; }

                ctx.save();
                ctx.translate(distorted.x, distorted.y);
                ctx.fillText(word[i], 0, 0);
                ctx.restore();
            }
            ctx.shadowBlur = 0;
        }

        function getDistortedPoint(x, y) {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let p1 = points[i][j], p2 = points[i+1][j];
                    let p3 = points[i+1][j+1], p4 = points[i][j+1];

                    if (x >= Math.min(p1.originalX, p2.originalX, p3.originalX, p4.originalX) &&
                        x <= Math.max(p1.originalX, p2.originalX, p3.originalX, p4.originalX) &&
                        y >= Math.min(p1.originalY, p2.originalY, p3.originalY, p4.originalY) &&
                        y <= Math.max(p1.originalY, p2.originalY, p3.originalY, p4.originalY)) {

                        let u = Math.max(0, Math.min(1, (x - p1.originalX) / (p2.originalX - p1.originalX)));
                        let v = Math.max(0, Math.min(1, (y - p1.originalY) / (p4.originalY - p1.originalY)));

                        return {
                            x: (p1.x + u * (p2.x - p1.x)) * (1 - v) + (p4.x + u * (p3.x - p4.x)) * v,
                            y: (p1.y + u * (p2.y - p1.y)) * (1 - v) + (p4.y + u * (p3.y - p4.y)) * v,
                            z: (p1.z + u * (p2.z - p1.z)) * (1 - v) + (p4.z + u * (p3.z - p4.z)) * v
                        };
                    }
                }
            }
            return {x, y, z: 0};
        }

        // ════════════════════════════════════════
        // CAMERA (getUserMedia directo, sem MediaPipe)
        // ════════════════════════════════════════
        async function startCamera() {
            document.getElementById('status').textContent = 'A iniciar camera...';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 320 },
                        height: { ideal: 240 },
                        facingMode: 'user',
                        frameRate: { ideal: 15 }
                    },
                    audio: false
                });

                webcam.srcObject = stream;
                await webcam.play();

                isRunning = true;
                document.getElementById('status').textContent = 'Camera ativa!';

                // Esconder status apos 4 segundos
                setTimeout(() => {
                    document.getElementById('status').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('status').style.display = 'none';
                    }, 2000);
                }, 4000);

                animate();

            } catch (error) {
                console.error('Erro camera:', error);
                document.getElementById('status').textContent = 'Erro: ' + error.message + ' — a tentar novamente...';
                setTimeout(startCamera, 3000);
            }
        }

        // ════════════════════════════════════════
        // ANIMATION LOOP
        // ════════════════════════════════════════
        let frameCount = 0;
        function animate() {
            if (!isRunning) return;

            // Detectar movimento a cada 2 frames (poupar CPU)
            frameCount++;
            if (frameCount % 2 === 0) {
                detectMotion();
            }

            render();
            requestAnimationFrame(animate);
        }

        // ════════════════════════════════════════
        // UI CONTROLS
        // ════════════════════════════════════════
        function updateSliders() {
            CONFIG.elasticity = parseFloat(document.getElementById('elasticity').value);
            CONFIG.gridDensity = parseInt(document.getElementById('gridDensity').value);
            CONFIG.captureRadius = parseInt(document.getElementById('captureRadius').value);
            CONFIG.videoOpacity = parseInt(document.getElementById('videoOpacity').value) / 100;
            CONFIG.sensitivity = parseInt(document.getElementById('sensitivity').value);
            CONFIG.forceMultiplier = parseInt(document.getElementById('forceMultiplier').value);

            document.getElementById('elasticity-value').textContent = CONFIG.elasticity.toFixed(2);
            document.getElementById('density-value').textContent = CONFIG.gridDensity;
            document.getElementById('capture-value').textContent = CONFIG.captureRadius;
            document.getElementById('opacity-value').textContent = document.getElementById('videoOpacity').value + '%';
            document.getElementById('sensitivity-value').textContent = CONFIG.sensitivity;
            document.getElementById('force-value').textContent = CONFIG.forceMultiplier;

            webcam.style.opacity = CONFIG.videoOpacity;
        }

        // ════════════════════════════════════════
        // RESPONSIVE RESIZE
        // ════════════════════════════════════════
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createGrid();
        }

        // ════════════════════════════════════════
        // INIT — auto-start imediato
        // ════════════════════════════════════════
        function init() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            webcam = document.getElementById('webcam');

            // Canvas para motion detection
            motionCanvas = document.getElementById('motionCanvas');
            motionCanvas.width = CAM_WIDTH;
            motionCanvas.height = CAM_HEIGHT;
            motionCtx = motionCanvas.getContext('2d', { willReadFrequently: true });

            prevCanvas = document.getElementById('prevCanvas');
            prevCanvas.width = CAM_WIDTH;
            prevCanvas.height = CAM_HEIGHT;
            prevCtx = prevCanvas.getContext('2d', { willReadFrequently: true });

            resizeCanvas();

            // Menu (aparece ao mover rato, esconde apos 3s)
            const menuToggle = document.getElementById('menuToggle');
            const controlsPanel = document.getElementById('controls');

            menuToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                menuToggle.classList.toggle('open');
                controlsPanel.classList.toggle('visible');
            });
            document.addEventListener('click', (e) => {
                if (!controlsPanel.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuToggle.classList.remove('open');
                    controlsPanel.classList.remove('visible');
                }
            });
            document.addEventListener('mousemove', () => {
                menuToggle.style.opacity = '1';
                document.body.style.cursor = 'default';
                clearTimeout(window._hideTimeout);
                window._hideTimeout = setTimeout(() => {
                    menuToggle.style.opacity = '0';
                    document.body.style.cursor = 'none';
                    menuToggle.classList.remove('open');
                    controlsPanel.classList.remove('visible');
                }, 3000);
            });

            // Sliders
            document.getElementById('elasticity').addEventListener('input', () => { updateSliders(); createGrid(); });
            document.getElementById('gridDensity').addEventListener('input', () => { updateSliders(); createGrid(); });
            document.getElementById('captureRadius').addEventListener('input', updateSliders);
            document.getElementById('videoOpacity').addEventListener('input', updateSliders);
            document.getElementById('sensitivity').addEventListener('input', updateSliders);
            document.getElementById('forceMultiplier').addEventListener('input', updateSliders);

            // Responsive
            window.addEventListener('resize', resizeCanvas);

            // AUTO-START: camera arranca imediatamente
            startCamera();
        }

        init();
    </script>
</body>
</html>
