<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TRAMA - Instalacao Interativa</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100vw; height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .canvas-container {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
        }

        #webcam {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.5;
        }

        #mainCanvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #status {
            position: absolute; bottom: 20px; left: 20px;
            color: white; background: rgba(0,0,0,0.8);
            padding: 10px 15px; border-radius: 5px;
            font-size: 14px; z-index: 100;
            transition: opacity 2s;
        }

        /* Menu hamburger (escondido por defeito, aparece ao mover rato) */
        #menuToggle {
            position: absolute; top: 10px; right: 10px;
            width: 36px; height: 36px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px; cursor: pointer; z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 4px; padding: 0;
            transition: opacity 0.5s;
            opacity: 0;
        }
        #menuToggle:hover { background: rgba(0,0,0,0.85); }
        #menuToggle span {
            display: block; width: 16px; height: 2px;
            background: white; border-radius: 1px;
            transition: transform 0.3s, opacity 0.3s;
        }
        #menuToggle.open span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
        #menuToggle.open span:nth-child(2) { opacity: 0; }
        #menuToggle.open span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

        #controls {
            position: absolute; top: 52px; right: 10px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 12px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            color: white; z-index: 150;
            min-width: 180px;
            transform: translateX(calc(100% + 20px));
            opacity: 0; pointer-events: none;
            transition: transform 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.3s ease;
        }
        #controls.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }

        .control-group { margin-bottom: 8px; }
        label { display: block; margin-bottom: 2px; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.7; }
        input[type="range"] { width: 100%; margin-top: 2px; height: 18px; }
        .value-display { text-align: right; font-size: 11px; margin-top: 1px; font-weight: bold; }
    </style>
</head>
<body>
    <button id="menuToggle" aria-label="Menu">
        <span></span><span></span><span></span>
    </button>

    <div id="controls">
        <div class="control-group">
            <label>Elasticidade</label>
            <input type="range" id="elasticity" min="0.02" max="0.15" step="0.01" value="0.08">
            <div class="value-display" id="elasticity-value">0.08</div>
        </div>
        <div class="control-group">
            <label>Densidade de Malha</label>
            <input type="range" id="gridDensity" min="15" max="35" step="2" value="25">
            <div class="value-display" id="density-value">25</div>
        </div>
        <div class="control-group">
            <label>Raio de Captura</label>
            <input type="range" id="captureRadius" min="30" max="100" step="5" value="60">
            <div class="value-display" id="capture-value">60</div>
        </div>
        <div class="control-group">
            <label>Opacidade Video</label>
            <input type="range" id="videoOpacity" min="0" max="100" step="5" value="50">
            <div class="value-display" id="opacity-value">50%</div>
        </div>
        <div class="control-group">
            <label>Opacidade Tracking</label>
            <input type="range" id="trackingOpacity" min="0" max="100" step="5" value="60">
            <div class="value-display" id="tracking-opacity-value">60%</div>
        </div>
    </div>

    <div id="status">A iniciar...</div>

    <div class="canvas-container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- MediaPipe LOCAL (offline) -->
    <script src="lib/camera_utils/camera_utils.js"></script>
    <script src="lib/hands/hands.js"></script>

    <script>
        // ════════════════════════════════════════
        // CONFIG
        // ════════════════════════════════════════
        const PI_CAMERA_WIDTH = 320;
        const PI_CAMERA_HEIGHT = 240;

        let canvas, ctx, webcam;
        let hands, camera;
        let isRunning = false;

        let allFingers = [];
        let allHandLandmarks = [];

        const CONFIG = {
            elasticity: 0.08,
            gridDensity: 20,
            captureRadius: 60,
            damping: 0.85,
            videoOpacity: 0.5,
            trackingOpacity: 0.6
        };

        let points = [];
        let cols, rows;

        // SVG TRAMA polylines
        const svgPolylines = [
            {points: "6980.13 6861.04 6566.36 7471.99 6239.5 7382.51 6239.5 6813.14 6612.26 6781.51 6747.18 6659.5 6923.82 6861.04", style: 1},
            {points: "6662.23 6736.32 6836.2 6955.03 6816.72 7739.5 7198.48 7739.5 6709.62 7207.18 6749.12 6984.73 6633.21 6762.57", style: 1},
            {points: "7198.48 7739.5 7208.96 6861.04 6923.82 6861.04 6836.2 6955.03 6796.27 7039.51", style: 1},
            {points: "6239.5 7382.51 6239.5 7739.5 6816.72 7739.5 6566.36 7471.99", style: 1},
            {points: "6239.5 6813.14 6240.71 6659.5 6747.18 6659.5 7218.69 6659.5 7208.96 6861.04", style: 1},
            {points: "7939.11 6861.04 7525.34 7471.99 7204.18 7413.44 7208.96 6861.04 7421.8 6960.37 7706.16 6659.5 7882.81 6861.04", style: 1},
            {points: "7471.77 6907.5 7795.18 6955.03 7775.71 7739.5 8157.47 7739.5 7668.61 7207.18 7757.63 6974.91 7442.75 6941.43", style: 1},
            {points: "8157.47 7739.5 8157.47 6861.04 7882.81 6861.04 7795.18 6955.03 7757.63 6974.91", style: 1},
            {points: "7198.48 7739.5 7775.71 7739.5 7525.34 7471.99", style: 1},
            {points: "7218.69 6659.5 7706.16 6659.5 8157.47 6659.5 8157.47 6861.04", style: 1},
            {points: "6749.12 6922.63 7289.77 7378.99 7237.96 7739.91 6749.12 7739.55 6837.03 7493.19 6570.78 7179.56 6749.12 6984.73", style: 2},
            {points: "6790.24 7438.08 6832.3 7081.37 7526.5 7102.85 7526.5 6659.5 7055.44 7220.98 7085.09 7431.06 6820.27 7470.09", style: 2},
            {points: "7526.5 6659.5 6747.18 6659.5 6749.12 6984.73 6832.3 7081.37 7085.09 7431.06", style: 2},
            {points: "7526.5 7739.5 7526.5 7102.85 7289.77 7378.99", style: 2},
            {points: "6570.78 7739.91 6570.78 7179.56 6570.78 6659.5 6752.74 6659.5", style: 2}
        ];

        const SVG_AREA = { x: 6239.5, y: 6659.5, width: 1917.97, height: 1080 };

        // ════════════════════════════════════════
        // POINT CLASS (sem som)
        // ════════════════════════════════════════
        class Point {
            constructor(x, y, col, row) {
                this.x = x; this.y = y; this.z = 0;
                this.originalX = x; this.originalY = y; this.originalZ = 0;
                this.vx = 0; this.vy = 0; this.vz = 0;
                this.col = col; this.row = row;
                this.attachedToFinger = false;
                this.attachedFingerX = 0; this.attachedFingerY = 0; this.attachedFingerZ = 0;
            }

            update() {
                if (this.attachedToFinger) {
                    this.x = this.attachedFingerX;
                    this.y = this.attachedFingerY;
                    this.z = this.attachedFingerZ;
                    this.vx = 0; this.vy = 0; this.vz = 0;
                } else {
                    let fx = (this.originalX - this.x) * CONFIG.elasticity;
                    let fy = (this.originalY - this.y) * CONFIG.elasticity;
                    let fz = (this.originalZ - this.z) * CONFIG.elasticity * 2;
                    this.vx += fx; this.vy += fy; this.vz += fz;
                    this.vx *= CONFIG.damping; this.vy *= CONFIG.damping; this.vz *= CONFIG.damping * 0.9;
                    this.x += this.vx; this.y += this.vy; this.z += this.vz;
                }
            }

            reset() { this.attachedToFinger = false; }
        }

        // ════════════════════════════════════════
        // GRID (responsive)
        // ════════════════════════════════════════
        function createGrid() {
            points = [];
            let scale = Math.min(canvas.width / SVG_AREA.width, canvas.height / SVG_AREA.height) * 0.8;
            let svgW = SVG_AREA.width * scale;
            let svgH = SVG_AREA.height * scale;
            let offsetX = (canvas.width - svgW) / 2;
            let offsetY = (canvas.height - svgH) / 2;

            cols = CONFIG.gridDensity;
            rows = Math.floor(cols * (svgH / svgW));

            let spacingX = svgW / cols;
            let spacingY = svgH / rows;

            for (let i = 0; i <= cols; i++) {
                points[i] = [];
                for (let j = 0; j <= rows; j++) {
                    points[i][j] = new Point(
                        offsetX + i * spacingX,
                        offsetY + j * spacingY,
                        i, j
                    );
                }
            }
        }

        // ════════════════════════════════════════
        // RENDER
        // ════════════════════════════════════════
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset attachment
            for (let i = 0; i <= cols; i++)
                for (let j = 0; j <= rows; j++)
                    points[i][j].reset();

            // Attach points to fingers
            for (let finger of allFingers) {
                for (let i = 0; i <= cols; i++) {
                    for (let j = 0; j <= rows; j++) {
                        let p = points[i][j];
                        let dist = Math.sqrt((p.x - finger.x) ** 2 + (p.y - finger.y) ** 2);
                        if (dist < CONFIG.captureRadius) {
                            p.attachedToFinger = true;
                            p.attachedFingerX = finger.x;
                            p.attachedFingerY = finger.y;
                            p.attachedFingerZ = finger.z * 500;
                        }
                    }
                }
            }

            // Update physics
            for (let i = 0; i <= cols; i++)
                for (let j = 0; j <= rows; j++)
                    points[i][j].update();

            // Draw
            drawHandsWireframe();
            drawDistortedPolylines();
        }

        function drawHandsWireframe() {
            const connections = [
                [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
            ];
            const opacity = CONFIG.trackingOpacity;

            for (let handIdx = 0; handIdx < allHandLandmarks.length; handIdx++) {
                let lm = allHandLandmarks[handIdx];

                // Conexoes
                ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let [a, b] of connections) {
                    ctx.moveTo(lm[a].x, lm[a].y);
                    ctx.lineTo(lm[b].x, lm[b].y);
                }
                ctx.stroke();

                // Pontas dos dedos (com tamanho baseado em Z)
                for (let idx of [4, 8, 12, 16, 20]) {
                    let z = lm[idx].z;
                    let size = 12 + z * 40;
                    let alpha = (0.7 + z * 0.3) * opacity;

                    ctx.fillStyle = `rgba(255, 68, 68, ${Math.max(0.3, Math.min(1, alpha))})`;
                    ctx.beginPath();
                    ctx.arc(lm[idx].x, lm[idx].y, Math.max(6, size), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 200, 50, ${Math.max(0.2, Math.min(0.8, alpha * 0.5))})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(lm[idx].x, lm[idx].y, Math.max(10, size + 5), 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Pulso
                ctx.fillStyle = `rgba(68, 136, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(lm[0].x, lm[0].y, 10, 0, Math.PI * 2);
                ctx.fill();
            }

            // Zonas de captura
            ctx.strokeStyle = `rgba(255, 200, 50, ${opacity * 0.5})`;
            ctx.lineWidth = 2;
            for (let finger of allFingers) {
                ctx.beginPath();
                ctx.arc(finger.x, finger.y, CONFIG.captureRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawDistortedPolylines() {
            let scale = Math.min(canvas.width / SVG_AREA.width, canvas.height / SVG_AREA.height) * 0.8;
            let svgW = SVG_AREA.width * scale;
            let svgH = SVG_AREA.height * scale;
            let offsetX = (canvas.width - svgW) / 2;
            let offsetY = (canvas.height - svgH) / 2;

            for (let polyline of svgPolylines) {
                let coords = polyline.points.trim().split(/\s+/);
                let pts = [];
                for (let i = 0; i < coords.length; i += 2) {
                    let svgX = parseFloat(coords[i]);
                    let svgY = parseFloat(coords[i + 1]);
                    let x = ((svgX - SVG_AREA.x) / SVG_AREA.width) * svgW + offsetX;
                    let y = ((svgY - SVG_AREA.y) / SVG_AREA.height) * svgH + offsetY;
                    pts.push(getDistortedPoint(x, y));
                }

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    let avgZ = (pts[i-1].z + pts[i].z) / 2;
                    let nZ = Math.max(0, Math.min(1, (avgZ + 150) / 300));
                    let baseWidth = polyline.style === 1 ? 3 : 2;

                    ctx.lineWidth = baseWidth * (0.5 + nZ * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + nZ * 0.6})`;

                    if (nZ > 0.6) {
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                        ctx.shadowBlur = (nZ - 0.6) * 20;
                    } else { ctx.shadowBlur = 0; }

                    ctx.lineTo(pts[i].x, pts[i].y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(pts[i].x, pts[i].y);
                }
                ctx.shadowBlur = 0;
            }

            drawDistortedTRAMA(offsetX, offsetY, svgW, svgH);
        }

        function drawDistortedTRAMA(offsetX, offsetY, svgW, svgH) {
            let word = 'TRAMA';
            let letterSpacing = svgW / 8;
            let startX = offsetX + svgW / 2 - (word.length * letterSpacing) / 2;
            let centerY = offsetY + svgH / 2;

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < word.length; i++) {
                let x = startX + i * letterSpacing + letterSpacing / 2;
                let distorted = getDistortedPoint(x, centerY);

                let nZ = Math.max(0, Math.min(1, (distorted.z + 150) / 300));
                let baseFontSize = Math.min(canvas.width, canvas.height) * 0.09;
                let size = baseFontSize * (0.6 + nZ * 0.8);

                ctx.font = `bold ${size}px Helvetica, Arial, sans-serif`;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + nZ * 0.5})`;

                if (nZ > 0.6) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = (nZ - 0.6) * 40;
                } else { ctx.shadowBlur = 0; }

                ctx.save();
                ctx.translate(distorted.x, distorted.y);
                ctx.fillText(word[i], 0, 0);
                ctx.restore();
            }
            ctx.shadowBlur = 0;
        }

        function getDistortedPoint(x, y) {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let p1 = points[i][j], p2 = points[i+1][j];
                    let p3 = points[i+1][j+1], p4 = points[i][j+1];

                    if (x >= Math.min(p1.originalX, p2.originalX, p3.originalX, p4.originalX) &&
                        x <= Math.max(p1.originalX, p2.originalX, p3.originalX, p4.originalX) &&
                        y >= Math.min(p1.originalY, p2.originalY, p3.originalY, p4.originalY) &&
                        y <= Math.max(p1.originalY, p2.originalY, p3.originalY, p4.originalY)) {

                        let u = Math.max(0, Math.min(1, (x - p1.originalX) / (p2.originalX - p1.originalX)));
                        let v = Math.max(0, Math.min(1, (y - p1.originalY) / (p4.originalY - p1.originalY)));

                        return {
                            x: (p1.x + u * (p2.x - p1.x)) * (1 - v) + (p4.x + u * (p3.x - p4.x)) * v,
                            y: (p1.y + u * (p2.y - p1.y)) * (1 - v) + (p4.y + u * (p3.y - p4.y)) * v,
                            z: (p1.z + u * (p2.z - p1.z)) * (1 - v) + (p4.z + u * (p3.z - p4.z)) * v
                        };
                    }
                }
            }
            return {x, y, z: 0};
        }

        // ════════════════════════════════════════
        // CAMERA & HAND TRACKING
        // ════════════════════════════════════════
        async function startCamera() {
            document.getElementById('status').textContent = 'A iniciar camera...';

            try {
                hands = new Hands({
                    locateFile: (file) => `lib/hands/${file}`
                });
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.4
                });
                hands.onResults(onHandResults);

                document.getElementById('status').textContent = 'A carregar modelo...';

                camera = new Camera(webcam, {
                    onFrame: async () => {
                        if (isRunning) {
                            await hands.send({ image: webcam });
                        }
                    },
                    width: PI_CAMERA_WIDTH,
                    height: PI_CAMERA_HEIGHT
                });

                await camera.start();
                isRunning = true;

                document.getElementById('status').textContent = 'Camera ativa!';

                // Esconder status apos 4 segundos
                setTimeout(() => {
                    document.getElementById('status').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('status').style.display = 'none';
                    }, 2000);
                }, 4000);

                animate();

            } catch (error) {
                console.error('Erro camera:', error);
                document.getElementById('status').textContent = 'Erro: ' + error.message + ' — a tentar novamente...';
                // Retry automatico apos 3 segundos
                setTimeout(startCamera, 3000);
            }
        }

        function onHandResults(results) {
            allFingers = [];
            allHandLandmarks = [];

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let handIdx = 0; handIdx < results.multiHandLandmarks.length; handIdx++) {
                    const lm = results.multiHandLandmarks[handIdx];
                    const landmarks = lm.map(p => ({
                        x: (1 - p.x) * canvas.width,
                        y: p.y * canvas.height,
                        z: (p.z || 0) * -1
                    }));
                    allHandLandmarks.push(landmarks);

                    for (let tipIdx of [4, 8, 12, 16, 20]) {
                        allFingers.push({
                            x: landmarks[tipIdx].x,
                            y: landmarks[tipIdx].y,
                            z: landmarks[tipIdx].z,
                            handIndex: handIdx,
                            fingerIndex: tipIdx
                        });
                    }
                }
            }
        }

        // ════════════════════════════════════════
        // ANIMATION
        // ════════════════════════════════════════
        function animate() {
            if (!isRunning) return;
            render();
            requestAnimationFrame(animate);
        }

        // ════════════════════════════════════════
        // UI CONTROLS
        // ════════════════════════════════════════
        function updateSliders() {
            CONFIG.elasticity = parseFloat(document.getElementById('elasticity').value);
            CONFIG.gridDensity = parseInt(document.getElementById('gridDensity').value);
            CONFIG.captureRadius = parseInt(document.getElementById('captureRadius').value);
            CONFIG.videoOpacity = parseInt(document.getElementById('videoOpacity').value) / 100;
            CONFIG.trackingOpacity = parseInt(document.getElementById('trackingOpacity').value) / 100;

            document.getElementById('elasticity-value').textContent = CONFIG.elasticity.toFixed(2);
            document.getElementById('density-value').textContent = CONFIG.gridDensity;
            document.getElementById('capture-value').textContent = CONFIG.captureRadius;
            document.getElementById('opacity-value').textContent = document.getElementById('videoOpacity').value + '%';
            document.getElementById('tracking-opacity-value').textContent = document.getElementById('trackingOpacity').value + '%';

            webcam.style.opacity = CONFIG.videoOpacity;
        }

        // ════════════════════════════════════════
        // RESPONSIVE RESIZE
        // ════════════════════════════════════════
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createGrid();
        }

        // ════════════════════════════════════════
        // INIT — auto-start imediato
        // ════════════════════════════════════════
        function init() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            webcam = document.getElementById('webcam');

            resizeCanvas();

            // Menu (aparece ao mover rato, esconde apos 3s)
            const menuToggle = document.getElementById('menuToggle');
            const controlsPanel = document.getElementById('controls');

            menuToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                menuToggle.classList.toggle('open');
                controlsPanel.classList.toggle('visible');
            });
            document.addEventListener('click', (e) => {
                if (!controlsPanel.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuToggle.classList.remove('open');
                    controlsPanel.classList.remove('visible');
                }
            });
            document.addEventListener('mousemove', () => {
                menuToggle.style.opacity = '1';
                document.body.style.cursor = 'default';
                clearTimeout(window._hideTimeout);
                window._hideTimeout = setTimeout(() => {
                    menuToggle.style.opacity = '0';
                    document.body.style.cursor = 'none';
                    menuToggle.classList.remove('open');
                    controlsPanel.classList.remove('visible');
                }, 3000);
            });

            // Sliders
            document.getElementById('elasticity').addEventListener('input', () => { updateSliders(); createGrid(); });
            document.getElementById('gridDensity').addEventListener('input', () => { updateSliders(); createGrid(); });
            document.getElementById('captureRadius').addEventListener('input', updateSliders);
            document.getElementById('videoOpacity').addEventListener('input', updateSliders);
            document.getElementById('trackingOpacity').addEventListener('input', updateSliders);

            // Responsive
            window.addEventListener('resize', resizeCanvas);

            // AUTO-START: camera arranca assim que MediaPipe carrega
            function waitAndStart() {
                if (typeof Hands !== 'undefined' && typeof Camera !== 'undefined') {
                    startCamera();
                } else {
                    document.getElementById('status').textContent = 'A carregar MediaPipe...';
                    setTimeout(waitAndStart, 300);
                }
            }
            // Iniciar imediatamente
            waitAndStart();
        }

        init();
    </script>
</body>
</html>
